\subsection{\coq}

In order to perform \premiseselection for \coq we first need to examine what objects in \coq look like, and what we exactly want to predict.

\subsubsection{\pcic}

Internally \coq represents all objects as terms \glsadd{termclass} of \cic \glsadd{cic}.
\cic is the Calculus of (Co)Inductive Constructions,
or the Calculus of Constructions \cite{coquand1988calculus} with inductive types and coinduction \cite{huet1987induction} \cite{coquand1990inductively}.
More recently, after \coq version 8, they switched to \pcic \glsadd{pcic}, or the Predicative Calculus of (Co)Inductive Constructions \cite{bertot2013interactive}.

\begin{definition}[term]\glsadd{termclass}
	A term is a noun or compound word of \pcic.
	A term is typically denoted by $\term$\glsadd{term}, with $\terms$\glsadd{terms} being the set of all terms.
\end{definition}
\begin{definition}[type]\glsadd{typeclass}
	A type is denoted by the semantic subclass of types inside the syntactic class term.
	A type is typically denoted by $\type$\glsadd{type}, with $\types$\glsadd{types} being the set of all types.
\end{definition}

All terms in \coq are typed.
We define $\term : \type$ to mean that term $\term$ is of type $\type$.
As a type is inside the syntactic class term, all types can be considered to be terms as well.
\[ \types \subseteq \terms \]

\begin{definition}[name]
	A name is an element in the set of names $\names$\glsadd{names}, and is bound to a term. A name is typically denoted by $\name$\glsadd{name}.
\end{definition}
Names can be both global (qualid) and local (ident).
In practice we transform the ident and qualid into a human readible canonical name.
For the purpose of this thesis we disregard this detail, and instead consider each name to be a unique identifier.
We are interested in these named terms for the purpose of \premiseselection,
as we wish to select terms which are most likely to help prove a conjecture.
We define $\name \objdef \term$ to mean that term $\term$ is bound to name $\name$.

\begin{definition}[sentence]\defgls{sentence}
	A sentence is a named term. It is comprised of a name $\name$ and a term $\term$. Each term has a type associated with it, which we denote with $\type$.
	We write each sentence to be of the form
	\[\name \objdef \term : \type\]
\end{definition}

Note that the a might be empty, for example as is the case with an axiom or an inductive datatype.
In the case that $\term$ is empty, we write $\name : \type$ instead.

\begin{definition}[sort]\defgls{type}
	The type of a type when manipulated as a term is called a sort.
	\pcic uses an infinite well-founded typing hierarchy of sorts, with base sorts \sortprop and \sortset, and with inductive sort \sorttype.
	The set of sorts named $\sorts$ is defined by
	\[\sorts \equiv \{ \sortprop, \sortset, \sorttype[{i}] ~|~ i \in \mathbb{N} \} \]

	Their types are defined as
	\[
		\begin{array}{rcl}
			\sortprop & : & \sorttype[1] \\
			\sortset & : & \sorttype[1] \\
			\forall_{i \in \mathbb{N}}~ \sorttype[i] & : & \sorttype[{i+1}]
		\end{array}
	\]
\end{definition}

The sort \sortprop is intended to be the type of logical propositions.
\sortset is intended to be the type of small sets such as booleans, the natural numbers, products, subsets and function types over these datatypes.
For example if we look at the types of the term $0$ and $\texttt{True}$:
	\[
		\begin{array}{rcl}
			0 & : & \texttt{nat} \\
			\texttt{nat} & : & \sortset \\
			\texttt{True} & : & \sortprop
		\end{array}
	\]

\subsubsection{\gallina}

A proof in \coq is a statement written in the \gallina language \cite{huet1992gallina} and stored in a file.
For a complete definition of the \gallina language please refer to the \coq reference manual\footnote{\coq Reference Manual, Chapter 1: The Gallina specification language\\ \url{https://coq.inria.fr/refman/Reference-Manual003.html}}.
A statement can reference other statements using their names.
These statements need not be stored in the same file.
Thus for a complete proof multiple files might need to be loaded.
These statements all have correlating \pcic terms associated with them.
A statement can be any of the following:
\begin{description}
	\item[Assumption] such as an axiom, conjecture and hypothesis, but also a parameter or variable.
		An assumption is a name with only a type associated with it.
	\item[Definition] for extending the environment with associations of names to terms.
	\item[Inductive] for inductive and coinductive datatypes.
	\item[Fixpoint] for fixpoint, or a block of functions defined by mutual well-founded recursion, and cofixpoint, or a block of terms defined by a mutual guarded co-recursion.
	\item[Assertion proof] for stating a proposition of which the proof is built.
		This creates type (the proposition) and an inhabitant of the type (the proof).
		This proof is always constructed using tactics, except in the case that a proof is admitted.
		In this case the proposition is converted into an axiom.
\end{description}

\coq translates \gallina statements contained in \coq vernac (.v) files to terms of \pcic.
Most notably all tactics are resolved (or executed) into terms.

\begin{definition}[{\coqobj[s]}]\defgls{coqobj}
	A \coqobj $s$ is a named term (also called a sentence).
	We denote the set of all \coq objects as $\objs$.
	For convenience we denote the ownership of the associated properties with a subscript.
	Each \coqobj $s \in \objs$ has a name $\name[s]$, a term $\term[s]$ and a type $\type[s]$ associated with it.
\end{definition}


Thus a \coq file can be considered to be a sequence of \coq objects:
$$ \name[1] \objdef \term[1] : \type[1], ~~ \name[2] \objdef \term[2] : \type[2], ~~ \ldots $$

A \coq corpus (or library) is a collection of \coq files, possibly including eachother.
It can thus be considered to be a partial ordered set of \coq objects, with the relation $R(a,b)$ for \coq objects $a, b \in \objs$ to be defined as
\[R(a,b) = \name[b] \texttt{~is referenced in~} \term[a]\]

\begin{figure}[H]
	\begin{lstlisting}[language=Coq, mathescape]
Inductive nat : Set :=
  | O : nat
  | S : nat -> nat.
Definition nat_id := fun x : nat => x.
Fixpoint plus (n m : nat) : nat :=
  match n with
  | O => m
  | S p => S (p + m)
  end.
Lemma plus_0_r : $\forall$ x , plus x 0 = x.
Proof.
intro x.
apply eq_sym.
induction x.
unfold plus.
apply eq_refl.
unfold plus.
apply f_equal.
exact IHx.
Qed.
	\end{lstlisting}
	\texttt{0} and \texttt{S} can be regarded as constructors or objects. \texttt{nat\_id} and \texttt{plus} can be regarded as functions, which are also objects.
	The following terms are all of sort \sortset.
	$$
		\begin{array}{rcl}
			\texttt{0} & : & \texttt{nat} \\
			\texttt{S} & : & \texttt{nat} \rightarrow \texttt{nat}
		\end{array}
	$$
	$$
		\begin{array}{rclcl}
			\texttt{nat\_id} & \objdef & \lambda x~.~x & : & \texttt{nat} \rightarrow \texttt{nat} \\
			\texttt{plus} & \objdef & \texttt{fix}~\ldots & : & \texttt{nat} \rightarrow \texttt{nat} \rightarrow \texttt{nat} \\
		\end{array}
	$$

	The following terms are of sort \sortprop, and are therefore always proofs:
	$$
		\begin{array}{rclcl}
			\texttt{nat\_ind} & \objdef & \texttt{fix}~\ldots & : &
				\forall P : \texttt{nat} \rightarrow \sortprop,~
				P~\texttt{0} \rightarrow (\forall n : \texttt{nat},~ P~n \rightarrow P~(\texttt{S}~n)) \rightarrow \forall n : \texttt{nat},~ P~n \\
			\texttt{plus\_0\_r} & \objdef & \ldots~\texttt{nat\_ind}~\ldots & : & \forall x : \texttt{nat},~ \texttt{plus}~x~0 = x
		\end{array}
	$$
	\caption{\coq file example defining natural numbers, and the corresponding \coq objects}
\end{figure}
