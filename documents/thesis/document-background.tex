\subsection{\coq}

In order to perform \premiseselection for \coq we first need to examine what objects in \coq look like, and what we exactly want to predict.

\subsubsection{\pcic}

Internally \coq represents all objects as terms \glsadd{termclass} of \cic \glsadd{cic}.
\cic is the Calculus of (Co)Inductive Constructions,
or the Calculus of Constructions \cite{coquand1988calculus} with inductive types and coinduction \cite{huet1987induction} \cite{coquand1990inductively}.
More recently, after \coq version 8, they switched to \pcic \glsadd{pcic}, or the Predicative Calculus of (Co)Inductive Constructions \cite{bertot2013interactive}.

\begin{definition}[term]\glsadd{termclass}
	A term is a noun or compound word of \pcic.
\end{definition}
\begin{definition}[type]\glsadd{typeclass}
	A type is denoted by the semantic subclass of types inside the syntactic class term.
\end{definition}

All terms in \coq are typed.
Terms can also be bound to names.
Names can be both global (qualid) and local (ident).
We are interested in these named terms for the purpose of \premiseselection, as we wish to select terms which are most likely to help prove a conjecture.

\begin{definition}[sentence]\defgls{sentence}
	A sentence is a named term. It is comprised of a name $\name$ and a term $\body$. Each term has a type associated with it, which we denote with $\type$.
	We write each sentence to be of the form
	\[\name \objdef \body : \type\]
\end{definition}

\begin{definition}[sort]\defgls{type}
	The type of a type when manipulated as a term is called a sort.
	\pcic uses an infinite well-founded typing hierarchy of sorts, with base sorts \sortprop and \sortset, and with inductive sort \sorttype.
	The set of sorts named $\sorts$ is defined by
	\[\sorts \equiv \{ \sortprop, \sortset, \sorttype[{i}] ~|~ i \in \mathbb{N} \} \]

	Their types are defined as
	\[
		\begin{array}{rcl}
			\sortprop & : & \sorttype[1] \\
			\sortset & : & \sorttype[1] \\
			\forall_{i \in \mathbb{N}}~ \sorttype[i] & : & \sorttype[{i+1}]
		\end{array}
	\]
\end{definition}

The sort \sortprop is intended to be the type of logical propositions.
\sortset is intended to be the type of small sets such as booleans, the natural numbers, products, subsets and function types over these datatypes.
For example if we look at the types of the term $0$ and $\texttt{True}$:
	\[
		\begin{array}{rcl}
			0 & : & \texttt{nat} \\
			\texttt{nat} & : & \sortset \\
			\texttt{True} & : & \sortprop
		\end{array}
	\]

\subsubsection{\gallina}

A proof in \coq is comprised of one or more files written in the \gallina language \cite{huet1992gallina}.
For a complete definition of the \gallina language please refer to the \coq reference manual\footnote{\coq Reference Manual, Chapter 1: The Gallina specification language\\ \url{https://coq.inria.fr/refman/Reference-Manual003.html}}.

Each file is, amongst other things, comprised of statements.
A statement can be any of the following:
\begin{description}
	\item[Assumption] such as an axiom, conjecture and hypothesis, but also a parameter or variable.
		An assumption is a name with only a type associated with it.
	\item[Definition] for extending the environment with associations of names to terms.
	\item[Inductive] for inductive and coinductive datatypes.
	\item[Fixpoint] for fixpoint, or a block of functions defined by mutual well-founded recursion, and cofixpoint, or a block of terms defined by a mutual guarded co-recursion.
	\item[Assertion proof] for stating a proposition of which the proof is built.
		This creates type (the proposition) and an inhabitant of the type (the proof).
		This proof is always constructed using tactics, except in the case that a proof is admitted.
		In this case the proposition is converted into an axiom.
\end{description}

\begin{figure}[H]
	\begin{lstlisting}[language=Coq, mathescape]
Inductive nat : Set :=
  | O : nat
  | S : nat -> nat.

Definition nat_id := $\ldots$ .

Fixpoint plus (n m : nat) : nat :=
  match n with
  | O => m
  | S p => S (p + m)
  end.

Lemma plus_0_r : $\forall$ x , plus x 0 = x.
Proof.
$\ldots$ nat_ind $\ldots$
Qed.
Definition plus_0_r n := eq_sym (nat_ind _ eq_refl $\ldots$ ).
	\end{lstlisting}
	\caption{\coq file example defining natural numbers}
\end{figure}

This high level description contained in \coq files is translated to terms of \pcic.
Most notably all tactics are resolved (or executed) into terms.
We consider everything contained in \pcic that has a name (ident) associated with it as a \coqobj.
Possibly each \coqobj might also have a global name (called a qualid).
In practice we transform the ident and qualid into a human readible canonical name.
For the purpose of this thesis we disregard this detail, and instead consider each \coqobj to have a unique identifier which we will call the name.

\begin{definition}[{\coqobj[s]}]\defgls{coqobj}
	A named exported \coq term $\body$ along with the name $\name$ and type $\type$ is called an \coq object and is of the form $\name \objdef \body : \type$.
	We denote the set of all \coq objects as $\objs$.
	Each \coqobj $s \in \objs$ has a name $\name[s]$.
	It also has a term $\body[s]$ and a type $\type[s]$ associated with it.
	Note that the term might be empty, for example as is the case with an axiom or an inductive datatype.
	In the case that $\body$ is empty, we write $\name : \type$ instead.
\end{definition}


Thus a \coq file can be considered to be a sequence of \coq objects:
$$ \name[1] \objdef \body[1] : \type[1], ~~ \name[2] \objdef \body[2] : \type[2], ~~ \ldots $$

A \coq corpus (or library) is a collection of \coq files, possibly including eachother.
It can thus be considered to be a partial ordered set of \coq objects.

\begin{figure}[H]
	$$
		\begin{array}{rclcl}
			\texttt{nat} & & & : & \sortset, \\
			\texttt{0} & & & : & \texttt{nat}, \\
			\texttt{S} & & & : & \texttt{nat} \rightarrow \texttt{nat}, \\
			\texttt{nat\_id} & \objdef & \lambda x~.~x & : & \texttt{nat} \rightarrow \texttt{nat}, \\
			\texttt{nat\_ind} & \objdef & \texttt{fix}~\ldots & : &
				\forall P : \texttt{nat} \rightarrow \sortprop,~
				P~\texttt{0} \rightarrow (\forall n : \texttt{nat},~ P~n \rightarrow P~(\texttt{S}~n)) \rightarrow \forall n : \texttt{nat},~ P~n, \\
			\texttt{plus} & \objdef & \texttt{fix}~\ldots & : & \texttt{nat} \rightarrow \texttt{nat} \rightarrow \texttt{nat}, \\
			\texttt{plus\_0\_r} & \objdef & \ldots~\texttt{nat\_ind}~\ldots & : & \forall x : \texttt{nat},~ \texttt{plus}~x~0 = x
		\end{array}
	$$
	\caption{\coqobj example of the preceding \coq file}
\end{figure}

\todo{\coqobj example}
