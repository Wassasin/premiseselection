\newcommand{\Ms}{Master's thesis\xspace}
\newcommand{\citationeeded}{[citation needed]}

% Generic
\newcommand{\machinelearning}{Machine Learning\xspace}
\newcommand{\crossvalidation}{cross validation\xspace}
\newcommand{\dagraph}{directed acyclic graph\xspace}
\newcommand{\premiseselection}{premise selection\xspace}
\newcommand{\Premiseselection}{Premise selection\xspace}

% Math
\newcommand{\nat}{\mathbb{N}}
\newcommand{\rat}{\mathbb{R}}

\newcommand{\powerset}[1]{\ensuremath{\mathcal{P}({#1})}}

\newcommand{\map}[2]{\ensuremath{\text{map}\left( {#1},２茯殓梏茴鬻泔眄犷潲荛铈轫蹴茆雉茴鬻珈矬筢蝙孱趄轭骈眭睚钺礤禁苠铙躜屙狒棼荛铈轫蹴溴筱蜷痿轱罱珧遽翦篝屐屙孱镦痫箦翳狒轶戾篌翳犷矧羼踽麸犰屐屙孱趔镦翳狒痫箦酏茴鬻泔眄犷潲茴翳鄄蓰荇屮酐铘椠１２茴鬻珈矬筢蝙孱趄铘椠钺礤禁苠铙躜屙狒棼茴翳铨佚溴筱蜷痿轱罱翳ゎ摞荇屮酐翳怙趑镯屐屙孱轭麸翎祆矧溴蝈箦酏茴鬻泔眄犷潲茕秣铙弭鄄蓰１茕秣钺蝌秣２
\newglossaryentry{downset}{name={\ensuremath{\downset{X}{x}}},
description={subset of a poset $X$ where each element is less than or equal to a given element $x$}}

% Languages
\newcommand{\cpp}{C++\xspace}
\newcommand{\ocaml}{OCaml\xspace}
\newcommand{\python}{Python\xspace}
\newcommand{\matlab}{MATLAB\xspace}
\newcommand{\xml}{XML\xspace}

% Projects
\newcommand{\preloader}{\texttt{preloader}\xspace}
\newcommand{\roerei}{\texttt{roerei}\xspace}
\newcommand{\coq}{Coq\xspace}
\newcommand{\coqide}{CoqIDE\xspace}

% Corpora
\newcommand{\compcert}{CompCert\xspace}
\newcommand{\corn}{CoRN\xspace}
\newcommand{\formalin}{Formalin\xspace}
\newcommand{\mathclasses}{Mathematical Classes\xspace}
\newcommand{\mathcomp}{Mathematical Components\xspace}

% Machine learning methods
\newcommand{\knn}{$k$-Nearest Neighbor\xspace}
\newcommand{\knnadaptive}{Adaptive Nearest Neighbor\xspace}
\newcommand{\nb}{Naive Bayes\xspace}
\newcommand{\ensemble}{Ensemble Learning\xspace}
\newcommand{\omniscient}{Omniscient\xspace}

% Coq terminology
\newcommand{\cprop}{\texttt{CProp}\xspace}

\newglossaryentry{termclass}{name={term},
description={a noun or compound word of \pcic, used by \gallina}}
\newglossaryentry{typeclass}{name={type},
description={the semantic subclass of types inside the syntactic class term}}
\newglossaryentry{sentence}{name={sentence},
description={a named term along with the corresponding type}}
\newglossaryentry{sort}{name={sort},
description={the type of a type when manipulated as term}}

\newcommand{\sorts}{\texttt{Sorts}\xspace}
\newglossaryentry{sorts}{name={\ensuremath{\sorts}}, sort=sorts,
description={the set of sorts}}
\newcommand{\sortprop}{\texttt{Prop}\xspace}
\newglossaryentry{sortprop}{name={\sortprop}, sort=prop,
description={the type of logical propositions}}
\newcommand{\sortset}{\texttt{Set}\xspace}
\newglossaryentry{sortset}{name={\sortset}, sort=set,
description={the type of small sets}}
\newcommand{\sorttype}[1][]{\texttt{Type}\ifthenelse{\equal{#1}{}}{}{({#1})}\xspace}
\newglossaryentry{sorttype}{name={\sorttype},
description={the type of types}}

\newcommand{\cic}{Cic\xspace}
\newglossaryentry{cic}{name={\cic},
description={Calculus of (Co)Inductive Constructions}}

\newcommand{\acic}{aCic\xspace}
\newglossaryentry{acic}{name={\acic},
description={Calculus of (Co)Inductive Constructions with Explicit Named Substitutions}}

\newcommand{\pcic}{pCic\xspace}
\newglossaryentry{pcic}{name={\pcic},
description={Predicative Calculus of (Co)Inductive Constructions}}

\newcommand{\gallina}{Gallina\xspace}
\newglossaryentry{gallina}{name={\gallina},
description={the specification language for \coq}}

% Paper-bound definitions
\newcommand{\coqobj}[1][]{\coq object\ifthenelse{\equal{#1}{}}{}{${#1}$}\xspace}
\newcommand{\coqobjs}{\coq objects\xspace}
\newglossaryentry{coqobj}{name={\coqobj[s]},
description={an object defined in \coq. Might be an inductive type, an axiom or a proof}}

\newglossaryentry{theorem}{name=theorem,
description={\coqobjs that have been proved based on previously established \coqobjs}}

\newglossaryentry{definition}{name=definition,
description={\coqobjs that are not theorems. Either simple constants or purely transformative operations on such constants}}

\newcommand{\name}[1][]{n_{#1}}
\newglossaryentry{name}{name={\ensuremath{\name[s]}},
description={canonical form of the name of the \coqobj[s]}}

\newcommand{\names}{\mathcal{N}}
\newglossaryentry{names}{name={\ensuremath{\names}},
description={the set of all names}}

\newcommand{\term}[1][]{t_{#1}}
\newglossaryentry{term}{name={\ensuremath{\term[s]}},
description={term of the \coqobj[s]}}

\newcommand{\terms}{\mathcal{T}}
\newglossaryentry{terms}{name={\ensuremath{\terms}},
description={the set of all terms}}

\newcommand{\emptyterm}{\top}
\newglossaryentry{emptyterm}{name={\ensuremath{\emptyterm}}, sort=term-empty,
description={the empty term}}

\newcommand{\type}[1][]{A_{#1}}
\newglossaryentry{type}{name={\ensuremath{\type[s]}},
description={type of the \coqobj[s]}}

\newcommand{\types}{\mathcal{A}}
\newglossaryentry{types}{name={\ensuremath{\types}},
description={the set of all types}}

\newcommand{\flattensym}{\nabla}
\newcommand{\flatten}[1]{\flattensym({#1})}
\newglossaryentry{flatten}{name={\ensuremath{\flattensym}}, sort=flatten,
description={extracts names from term or type, and return the set of names}}

\newcommand{\countsym}{\#}

\newcommand{\countoccursym}{\flattensym_\countsym}
\newcommand{\countoccur}[1]{\countoccursym({#1})}
\newglossaryentry{countoccur}{name={\ensuremath{\countoccursym}}, sort=flatten-countoccur,
description={extracts names from term or type along with their number of occurances}}

\newcommand{\depthsym}{D}

\newcommand{\depthoccursym}{\flattensym_\depthsym}
\newcommand{\depthoccur}[1]{\depthoccursym({#1})}
\newglossaryentry{depthoccur}{name={\ensuremath{\depthoccursym}}, sort=flatten-depthoccur,
description={extracts names from term or type along with their depth}}

\newcommand{\termset}[1]{\flatten{\term[#1]}}
\newglossaryentry{termset}{name={\ensuremath{\termset{s}}}, sort=flatten-termset,
description={set of names of all objects in the term of \coqobj[s]}}

\newcommand{\typeset}[1]{\flatten{\type[#1]}}
\newglossaryentry{typeset}{name={\ensuremath{\typeset{s}}}, sort=flatten-typeset,
description={set of names of all objects in the type of \coqobj[s]}}

\newcommand{\defs}[1][]{\texttt{Defs}_{#1}}
\newglossaryentry{defs}{name={\ensuremath{\defs}},
description={set of names of all objects in the types of all objects; used as the base of the set of features}}
\newcommand{\thms}[1][]{\texttt{Thms}_{#1}}
\newglossaryentry{thms}{name={\ensuremath{\thms}},
description={set of names of all objects in the terms of all objects, excluding all $\defs$; used as set of dependencies}}

\newcommand{\oocover}{100Cover\xspace}
\newcommand{\oocoverf}[2]{\ensuremath{\text{100Cover}({#1}, {#2})}}
\newcommand{\ooprecision}{100Precision\xspace}
\newcommand{\ooprecisionf}[2]{\ensuremath{\text{100Precision}({#1}, {#2})}}
\newcommand{\recall}{Recall\xspace}
\newcommand{\recallf}[2]{\ensuremath{\text{Recall}({#1}, {#2})}}
\newcommand{\rank}{Rank\xspace}
\newcommand{\auc}{AUC\xspace}
\newcommand{\volume}{Volume\xspace}

\newcommand{\featurekeys}{Z}
\newglossaryentry{featurekeys}{name={\ensuremath{\featurekeys}},
description={set of feature keys, or the set of the aspects with which an object can be described; based on the set of definitions $\defs$, but possibly extended with other aspects}}

\newcommand{\features}[2]{F^{#1}_{#2}}
\newglossaryentry{features}{name={\ensuremath{\features{}{}}},
description={function which computes the numeric values describing a \coqobj. These values are considered to be the features of the \coq object}}

\newcommand{\depsym}{D}

\newcommand{\deps}[1]{\depsym_{#1}}
\newglossaryentry{deps}{name={\ensuremath{\deps{s}}},
description={set of names of objects which have been used to define or prove a \coqobj $s$}}

\newcommand{\depset}{\depsym}
\newglossaryentry{depset}{name={\ensuremath{\depset}},
description={set of all possible dependencies}}

\newcommand{\depstrans}[1][]{\deps{#1}^*}

\newcommand{\parentsym}{P}

\newcommand{\parents}[1][]{\parentsym_{#1}}
\newglossaryentry{parentsym}{name={\ensuremath{\parents{s}}},
description={set of names of objects which use \coqobj $s$ to be defined to or proven}}

\newcommand{\parentstrans}[1][]{\parents[{#1}]^*}

\newcommand{\predictors}{\mathcal{P}}
\newglossaryentry{predictors}{name={\ensuremath{\predictors}},
description={set of predictor functions}}

\newcommand{\rankings}{\mathcal{R}}
\newglossaryentry{rankings}{name={\ensuremath{\rankings}},
description={set of rankings}}

\newcommand{\dist}{\text{dist}}
\newglossaryentry{dist}{name={\ensuremath{\dist}},
description={the euclidean distance between two types $a, b \in \types$ computed using the features $\features{}{a}$ and $\features{}{b}$ of those types}}

\newcommand{\objsym}{\ensuremath{S}}
\newcommand{\objs}[1][]{\ensuremath{\objsym_{#1}}}
\newcommand{\trainset}{\objs[{\text{train}}]}
\newcommand{\testset}{\objs[{\text{test}}]}

\newcommand{\objdef}{:=}

\newcommand{\topn}[2]{\ensuremath{\mathtt{top}_{#1}({#2})}}
\newcommand{\required}[1][]{\ensuremath{{\mathtt{req}}_{#1}}}
\newcommand{\suggestions}[1]{\ensuremath{\mathtt{sugg}_{#1}}}

\newcommand{\ltr}{\emph{Learning to rank}\xspace}

% Adarank

\newcommand{\query}{\ensuremath{q}}
\newcommand{\doc}{\ensuremath{d}}
\newcommand{\docs}[1]{\ensuremath{\mathbf{d}_{#1}}}
\newcommand{\queries}{\ensuremath{Q}}
\newcommand{\rankdoc}[1]{\ensuremath{y}_{#1}}
\newcommand{\irfeatures}{\ensuremath{\mathcal{X}}}

\newcommand{\idf}{\ensuremath{\mathbf{idf}}}
